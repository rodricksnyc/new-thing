{"version":3,"file":"index.production.js","sources":["../../../virtual-core/build/esm/index.js","../../src/index.tsx"],"sourcesContent":["/**\n * virtual-core\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return () => {\n    let depTime;\n    if (opts.key && opts.debug != null && opts.debug()) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n\n    if (!depsChanged) {\n      return result;\n    }\n\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug != null && opts.debug()) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null ? void 0 : opts.onChange == null ? void 0 : opts.onChange(result);\n\n    if (opts.key && opts.debug != null && opts.debug()) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n\n      const pad = (str, num) => {\n        str = String(str);\n\n        while (str.length < num) {\n          str = ' ' + str;\n        }\n\n        return str;\n      };\n\n      console.info(\"%c\\u23F1 \" + pad(resultEndTime, 5) + \" /\" + pad(depEndTime, 5) + \" ms\", \"\\n            font-size: .6rem;\\n            font-weight: bold;\\n            color: hsl(\" + Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120)) + \"deg 100% 31%);\", opts == null ? void 0 : opts.key);\n    }\n\n    return result;\n  };\n}\n\n//\nconst defaultKeyExtractor = index => index;\nconst defaultRangeExtractor = range => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\n\nconst memoRectCallback = (instance, cb) => {\n  let prev = {\n    height: -1,\n    width: -1\n  };\n  return rect => {\n    if (instance.options.horizontal ? rect.width !== prev.width : rect.height !== prev.height) {\n      cb(rect);\n    }\n\n    prev = rect;\n  };\n};\n\nconst observeElementRect = (instance, cb) => {\n  const observer = new ResizeObserver(entries => {\n    var _entries$, _entries$2;\n\n    cb({\n      width: (_entries$ = entries[0]) == null ? void 0 : _entries$.contentRect.width,\n      height: (_entries$2 = entries[0]) == null ? void 0 : _entries$2.contentRect.height\n    });\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  cb(instance.scrollElement.getBoundingClientRect());\n  observer.observe(instance.scrollElement);\n  return () => {\n    observer.unobserve(instance.scrollElement);\n  };\n};\nconst observeWindowRect = (instance, cb) => {\n  const memoizedCallback = memoRectCallback(instance, cb);\n\n  const onResize = () => memoizedCallback({\n    width: instance.scrollElement.innerWidth,\n    height: instance.scrollElement.innerHeight\n  });\n\n  if (!instance.scrollElement) {\n    return;\n  }\n\n  onResize();\n  instance.scrollElement.addEventListener('resize', onResize, {\n    capture: false,\n    passive: true\n  });\n  return () => {\n    instance.scrollElement.removeEventListener('resize', onResize);\n  };\n};\nconst scrollProps = {\n  element: ['scrollLeft', 'scrollTop'],\n  window: ['scrollX', 'scrollY']\n};\n\nconst createOffsetObserver = mode => {\n  return (instance, cb) => {\n    if (!instance.scrollElement) {\n      return;\n    }\n\n    const propX = scrollProps[mode][0];\n    const propY = scrollProps[mode][1];\n    let prevX = instance.scrollElement[propX];\n    let prevY = instance.scrollElement[propY];\n\n    const scroll = () => {\n      cb(instance.scrollElement[instance.options.horizontal ? propX : propY]);\n    };\n\n    scroll();\n\n    const onScroll = e => {\n      const target = e.currentTarget;\n      const scrollX = target[propX];\n      const scrollY = target[propY];\n\n      if (instance.options.horizontal ? prevX - scrollX : prevY - scrollY) {\n        scroll();\n      }\n\n      prevX = scrollX;\n      prevY = scrollY;\n    };\n\n    instance.scrollElement.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return () => {\n      instance.scrollElement.removeEventListener('scroll', onScroll);\n    };\n  };\n};\n\nconst observeElementOffset = createOffsetObserver('element');\nconst observeWindowOffset = createOffsetObserver('window');\nconst measureElement = (element, instance) => {\n  return element.getBoundingClientRect()[instance.options.horizontal ? 'width' : 'height'];\n};\nconst windowScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme;\n  (_instance$scrollEleme = instance.scrollElement) == null ? void 0 : _instance$scrollEleme.scrollTo == null ? void 0 : _instance$scrollEleme.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nconst elementScroll = (offset, canSmooth, instance) => {\n  var _instance$scrollEleme2;\n  (_instance$scrollEleme2 = instance.scrollElement) == null ? void 0 : _instance$scrollEleme2.scrollTo == null ? void 0 : _instance$scrollEleme2.scrollTo({\n    [instance.options.horizontal ? 'left' : 'top']: offset,\n    behavior: canSmooth ? 'smooth' : undefined\n  });\n};\nclass Virtualizer {\n  constructor(_opts) {\n    var _this = this;\n\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.measurementsCache = [];\n    this.itemMeasurementsCache = {};\n    this.pendingMeasuredCacheIndexes = [];\n    this.measureElementCache = {};\n    this.range = {\n      startIndex: 0,\n      endIndex: 0\n    };\n\n    this.setOptions = opts => {\n      Object.entries(opts).forEach(_ref => {\n        let [key, value] = _ref;\n        if (typeof value === 'undefined') delete opts[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        enableSmoothScroll: true,\n        onChange: () => {},\n        measureElement,\n        initialRect: {\n          width: 0,\n          height: 0\n        },\n        ...opts\n      };\n    };\n\n    this.notify = () => {\n      var _this$options$onChang, _this$options;\n\n      (_this$options$onChang = (_this$options = this.options).onChange) == null ? void 0 : _this$options$onChang.call(_this$options, this);\n    };\n\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach(d => d());\n      this.unsubs = [];\n      this.scrollElement = null;\n    };\n\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n\n    this._willUpdate = () => {\n      const scrollElement = this.options.getScrollElement();\n\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        this.scrollElement = scrollElement;\n\n        this._scrollToOffset(this.scrollOffset, false);\n\n        this.unsubs.push(this.options.observeElementRect(this, rect => {\n          this.scrollRect = rect;\n          this.calculateRange();\n        }));\n        this.unsubs.push(this.options.observeElementOffset(this, offset => {\n          this.scrollOffset = offset;\n          this.calculateRange();\n        }));\n      }\n    };\n\n    this.getSize = () => {\n      return this.scrollRect[this.options.horizontal ? 'width' : 'height'];\n    };\n\n    this.getMeasurements = memo(() => [this.options.count, this.options.paddingStart, this.options.getItemKey, this.itemMeasurementsCache], (count, paddingStart, getItemKey, measurementsCache) => {\n      const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n      this.pendingMeasuredCacheIndexes = [];\n      const measurements = this.measurementsCache.slice(0, min);\n\n      for (let i = min; i < count; i++) {\n        const key = getItemKey(i);\n        const measuredSize = measurementsCache[key];\n        const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n        const size = typeof measuredSize === 'number' ? measuredSize : this.options.estimateSize(i);\n        const end = start + size;\n        measurements[i] = {\n          index: i,\n          start,\n          size,\n          end,\n          key\n        };\n      }\n\n      this.measurementsCache = measurements;\n      return measurements;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getMeasurements',\n      debug: () => this.options.debug\n    });\n    this.calculateRange = memo(() => [this.getMeasurements(), this.getSize(), this.scrollOffset], (measurements, outerSize, scrollOffset) => {\n      const range = calculateRange({\n        measurements,\n        outerSize,\n        scrollOffset\n      });\n\n      if (range.startIndex !== this.range.startIndex || range.endIndex !== this.range.endIndex) {\n        this.range = range;\n        this.notify();\n      }\n\n      return this.range;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'calculateRange',\n      debug: () => this.options.debug\n    });\n    this.getIndexes = memo(() => [this.options.rangeExtractor, this.range, this.options.overscan, this.options.count], (rangeExtractor, range, overscan, count) => {\n      return rangeExtractor({ ...range,\n        overscan,\n        count: count\n      });\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n    this.getVirtualItems = memo(() => [this.getIndexes(), this.getMeasurements(), this.options.measureElement], (indexes, measurements, measureElement) => {\n      const makeMeasureElement = index => measurableItem => {\n        var _this$itemMeasurement;\n\n        const item = this.measurementsCache[index];\n\n        if (!measurableItem) {\n          return;\n        }\n\n        const measuredItemSize = measureElement(measurableItem, this);\n        const itemSize = (_this$itemMeasurement = this.itemMeasurementsCache[item.key]) != null ? _this$itemMeasurement : item.size;\n\n        if (measuredItemSize !== itemSize) {\n          if (item.start < this.scrollOffset) {\n            if (process.env.NODE_ENV !== 'production' && this.options.debug) {\n              console.info('correction', measuredItemSize - itemSize);\n            }\n\n            if (!this.destinationOffset) {\n              this._scrollToOffset(this.scrollOffset + (measuredItemSize - itemSize), false);\n            }\n          }\n\n          this.pendingMeasuredCacheIndexes.push(index);\n          this.itemMeasurementsCache = { ...this.itemMeasurementsCache,\n            [item.key]: measuredItemSize\n          };\n          this.notify();\n        }\n      };\n\n      const virtualItems = [];\n      const currentMeasureElements = {};\n\n      for (let k = 0, len = indexes.length; k < len; k++) {\n        var _this$measureElementC;\n\n        const i = indexes[k];\n        const measurement = measurements[i];\n        const item = { ...measurement,\n          measureElement: currentMeasureElements[i] = (_this$measureElementC = this.measureElementCache[i]) != null ? _this$measureElementC : makeMeasureElement(i)\n        };\n        virtualItems.push(item);\n      }\n\n      this.measureElementCache = currentMeasureElements;\n      return virtualItems;\n    }, {\n      key: process.env.NODE_ENV !== 'production' && 'getIndexes',\n      debug: () => this.options.debug\n    });\n\n    this.scrollToOffset = function (toOffset, _temp) {\n      let {\n        align = 'start',\n        smoothScroll = _this.options.enableSmoothScroll\n      } = _temp === void 0 ? {} : _temp;\n      const offset = _this.scrollOffset;\n\n      const size = _this.getSize();\n\n      if (align === 'auto') {\n        if (toOffset <= offset) {\n          align = 'start';\n        } else if (toOffset >= offset + size) {\n          align = 'end';\n        } else {\n          align = 'start';\n        }\n      }\n\n      if (align === 'start') {\n        _this._scrollToOffset(toOffset, smoothScroll);\n      } else if (align === 'end') {\n        _this._scrollToOffset(toOffset - size, smoothScroll);\n      } else if (align === 'center') {\n        _this._scrollToOffset(toOffset - size / 2, smoothScroll);\n      }\n    };\n\n    this.scrollToIndex = function (index, _temp2) {\n      let {\n        align = 'auto',\n        smoothScroll = _this.options.enableSmoothScroll,\n        ...rest\n      } = _temp2 === void 0 ? {} : _temp2;\n\n      const measurements = _this.getMeasurements();\n\n      const offset = _this.scrollOffset;\n\n      const size = _this.getSize();\n\n      const {\n        count\n      } = _this.options;\n      const measurement = measurements[Math.max(0, Math.min(index, count - 1))];\n\n      if (!measurement) {\n        return;\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= offset + size - _this.options.scrollPaddingEnd) {\n          align = 'end';\n        } else if (measurement.start <= offset + _this.options.scrollPaddingStart) {\n          align = 'start';\n        } else {\n          return;\n        }\n      }\n\n      const toOffset = align === 'end' ? measurement.end + _this.options.scrollPaddingEnd : measurement.start - _this.options.scrollPaddingStart;\n\n      _this.scrollToOffset(toOffset, {\n        align,\n        smoothScroll,\n        ...rest\n      });\n    };\n\n    this.getTotalSize = () => {\n      var _this$getMeasurements;\n\n      return (((_this$getMeasurements = this.getMeasurements()[this.options.count - 1]) == null ? void 0 : _this$getMeasurements.end) || this.options.paddingStart) + this.options.paddingEnd;\n    };\n\n    this._scrollToOffset = (offset, canSmooth) => {\n      clearTimeout(this.scrollCheckFrame);\n      this.destinationOffset = offset;\n      this.options.scrollToFn(offset, canSmooth, this);\n      let scrollCheckFrame;\n\n      const check = () => {\n        let lastOffset = this.scrollOffset;\n        this.scrollCheckFrame = scrollCheckFrame = setTimeout(() => {\n          if (this.scrollCheckFrame !== scrollCheckFrame) {\n            return;\n          }\n\n          if (this.scrollOffset === lastOffset) {\n            this.destinationOffset = undefined;\n            return;\n          }\n\n          lastOffset = this.scrollOffset;\n          check();\n        }, 100);\n      };\n\n      check();\n    };\n\n    this.measure = () => {\n      this.itemMeasurementsCache = {};\n      this.notify();\n    };\n\n    this.setOptions(_opts);\n    this.scrollRect = this.options.initialRect;\n    this.scrollOffset = this.options.initialOffset;\n    this.calculateRange();\n  }\n\n}\n\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref2) {\n  let {\n    measurements,\n    outerSize,\n    scrollOffset\n  } = _ref2;\n  const count = measurements.length - 1;\n\n  const getOffset = index => measurements[index].start;\n\n  const startIndex = findNearestBinarySearch(0, count, getOffset, scrollOffset);\n  let endIndex = startIndex;\n\n  while (endIndex < count && measurements[endIndex].end < scrollOffset + outerSize) {\n    endIndex++;\n  }\n\n  return {\n    startIndex,\n    endIndex\n  };\n}\n\nexport { Virtualizer, defaultKeyExtractor, defaultRangeExtractor, elementScroll, measureElement, memo, observeElementOffset, observeElementRect, observeWindowOffset, observeWindowRect, windowScroll };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react'\nimport {\n  elementScroll,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  PartialKeys,\n  Virtualizer,\n  VirtualizerOptions,\n  windowScroll,\n} from '@tanstack/virtual-core'\nexport * from '@tanstack/virtual-core'\n\n//\n\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nfunction useVirtualizerBase<TScrollElement, TItemElement = unknown>(\n  options: VirtualizerOptions<TScrollElement, TItemElement>,\n): Virtualizer<TScrollElement, TItemElement> {\n  const rerender = React.useReducer(() => ({}), {})[1]\n\n  const resolvedOptions: VirtualizerOptions<TScrollElement, TItemElement> = {\n    ...options,\n    onChange: (instance) => {\n      rerender()\n      options.onChange?.(instance)\n    },\n  }\n\n  const [instance] = React.useState(\n    () => new Virtualizer<TScrollElement, TItemElement>(resolvedOptions),\n  )\n\n  instance.setOptions(resolvedOptions)\n\n  React.useEffect(() => {\n    return instance._didMount()\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate()\n  })\n\n  return instance\n}\n\nexport function useVirtualizer<TScrollElement, TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<TScrollElement, TItemElement>,\n    'observeElementRect' | 'observeElementOffset' | 'scrollToFn'\n  >,\n): Virtualizer<TScrollElement, TItemElement> {\n  return useVirtualizerBase<TScrollElement, TItemElement>({\n    observeElementRect: observeElementRect,\n    observeElementOffset: observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options,\n  })\n}\n\nexport function useWindowVirtualizer<TItemElement = unknown>(\n  options: PartialKeys<\n    VirtualizerOptions<Window, TItemElement>,\n    | 'getScrollElement'\n    | 'observeElementRect'\n    | 'observeElementOffset'\n    | 'scrollToFn'\n  >,\n): Virtualizer<Window, TItemElement> {\n  return useVirtualizerBase<Window, TItemElement>({\n    getScrollElement: () => (typeof window !== 'undefined' ? window : null!),\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    ...options,\n  })\n}\n"],"names":["memo","getDeps","fn","opts","result","deps","depTime","key","debug","Date","now","newDeps","length","some","dep","index","resultTime","onChange","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","defaultKeyExtractor","defaultRangeExtractor","range","start","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","observer","ResizeObserver","entries","_entries$","_entries$2","width","contentRect","height","scrollElement","getBoundingClientRect","observe","unobserve","observeWindowRect","memoizedCallback","prev","rect","options","horizontal","memoRectCallback","onResize","innerWidth","innerHeight","addEventListener","capture","passive","removeEventListener","scrollProps","element","window","createOffsetObserver","mode","propX","propY","prevX","prevY","scroll","onScroll","e","target","currentTarget","scrollX","scrollY","observeElementOffset","observeWindowOffset","measureElement","windowScroll","offset","canSmooth","_instance$scrollEleme","scrollTo","behavior","undefined","elementScroll","_instance$scrollEleme2","Virtualizer","constructor","_opts","_this","this","unsubs","measurementsCache","itemMeasurementsCache","pendingMeasuredCacheIndexes","measureElementCache","setOptions","Object","forEach","_ref","value","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","enableSmoothScroll","initialRect","notify","_this$options$onChang","_this$options","call","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","_scrollToOffset","scrollOffset","scrollRect","calculateRange","getSize","getMeasurements","measurements","slice","measuredSize","size","estimateSize","outerSize","_ref2","low","high","getCurrentValue","middle","currentValue","findNearestBinarySearch","getIndexes","getVirtualItems","indexes","makeMeasureElement","measurableItem","_this$itemMeasurement","item","measuredItemSize","itemSize","destinationOffset","virtualItems","currentMeasureElements","k","len","_this$measureElementC","scrollToOffset","toOffset","_temp","align","smoothScroll","scrollToIndex","_temp2","rest","measurement","getTotalSize","_this$getMeasurements","scrollCheckFrame","clearTimeout","scrollToFn","check","lastOffset","setTimeout","measure","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","useVirtualizerBase","rerender","useReducer","resolvedOptions","useState"],"mappings":"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"}